import React, { useState, useEffect } from 'react';
import CodeEditor from '../../components/codeEditor/CodeEditor';
import DotGraphViewer from '../../components/output/dotGraphViewer/DotGraphViewer';
import SubmitCodeBar from '../../components/submitCode/submitCodeBar/SubmitCodeBar';
import OutputMenuBar from '../../components/output/outputMenuBar/OutputMenuBar';
import TerminalOutput from '../../components/output/terminalOutput/TerminalOutput';
import CodeGPT from '../../components/output/codeGPT/CodeGPT';
import LLVMIR from '../../components/output/LLVMIR/LLVMIR';
import submitCodeFetch from '../../api.ts';
import NavBar from '../../components/navBar/Navbar.tsx';
import './graphsPage.css';
import { compressToEncodedURIComponent, decompressFromEncodedURIComponent } from 'lz-string';
import ShareLZSettingsModal from '../../components/shareLZSettingsModal/shareLZSettingsModal.tsx';

/*
  The output tabs
    Graph: shows all the graphs generated by the backend
    CodeGPT: user can ask questions about code, bugs, graphs etc
    LLVMIR: LLVM IR generated by clang sent from backend
    Terminal Output: Output generated by the executables such as svf-ex, mta, saber
*/
type OutputType = 'Graph' | 'CodeGPT' | 'LLVMIR' | 'Terminal Output';

/*
  Used when decompressing settings from URL
  From the url we placed the decompressed settings into this interface type
  code = C code saved from URL
  selectedCompileOptions = selected compile options saved from URL
  selectedExecutableOptions = selected Executable Options saved from URL
*/
interface DecompressedSettings {
  code?: string;
  selectedCompileOptions?: compileOption[];
  selectedExecutableOptions?: string[];
}

/*
  This is used to display the compile options in the frontend
  value = value when user clicks on selecting this compile option
  label = what the user sees in the front end
*/
interface compileOption {
  value: string;
  label: string;
}

/*
  Compile options that user can pick to add when compiling their code using clang
*/
const compileOptions = [
  { value: '-g', label: '-g' },
  { value: '-c', label: '-c' },
  { value: '-S', label: '-S' },
  { value: '-fno-discard-value-names', label: '-fno-discard-value-names' },
  { value: '-emit-llvm', label: '-emit-llvm' },
  // { value: '-pass-exit-codes', label: '-pass-exit-codes' }, // This argument is causing an error in clang
  { value: '-E', label: '-E' },
  { value: '-v', label: '-v' },
  { value: '-pipe', label: '-pipe' },
  { value: '--help', label: '--help' },
  // { value: '-fcanon-prefix-map', label: '-fcanon-prefix-map' }, // This argument is causing an error in clang
];

/*
  Executables (SVF tools) that the user can select
  The backend will run the user C code into these exectuables
*/
const executableOptions = [
  { value: 'mta', label: 'mta' },
  { value: 'saber', label: 'saber (Memory Leak Detector)' },
  { value: 'ae -overflow', label: 'ae (Buffer Overflow Detector)' },
];

function GraphsPage() {
  const inlineStyles = {
    container: {
      display: 'flex',
    },
  };

  // List of bugs in code
  const [codeError, setCodeError] = useState([])
  // Line number of 
  const [currCodeLineNum, setCurrCodeLineNum] = useState(0);

  // Stores current output/ tab that user is viewing
  const [currentOutput, setCurrentOutput] = useState<OutputType>('Graph');

  // User selected compile options
  const [selectedCompileOptions, setSelectedCompileOptions] = useState([compileOptions[0], compileOptions[1], compileOptions[2], compileOptions[3], compileOptions[4]]);
  
  // User selected Executable options
  const [selectedExecutableOptions, setSelectedExecutableOptions] = useState([]);

  const [lineNumDetails, setLineNumDetails] = useState<{ [key: string]: { nodeOrllvm: string[], colour: string } }>({});
  
  // C code that user inputted
  const [code, setCode] = useState(
    `
    #include <stdio.h>
    #include <stdlib.h>

    typedef struct {
      int *data;
      int size;
    } IntArray;

    IntArray* createIntArray(int size) {
        IntArray *arr = malloc(sizeof(IntArray));
        arr->size = size;
        arr->data = malloc(size * sizeof(int));
        for (int i = 0; i < size; i++) {
            arr->data[i] = i; // Initialize the array
        }
        return arr;
    }

    void useIntArray(IntArray *arr) {
        for (int i = 0; i < arr->size; i++) {
            printf("%d ", arr->data[i]);
        }
        printf("n");
    }

    int main() {
        IntArray *array1 = createIntArray(5);
        IntArray *array2 = createIntArray(10);

        useIntArray(array1);
        useIntArray(array2);

        return 0;
    }
    `
  );

  // A set of line numbers to highlight in the code editor
  const [lineNumToHighlight, setlineNumToHighlight] = useState<Set<number>>(new Set());

  // Terminal output string to be displayed
  const [terminalOutputString, setTerminalOutputString] = useState('Run the code to see the terminal output here');

  // LLVM IR string to be displayed
  const [llvmIRString, setllvmIRString] = useState('Run the code to see the LLVM IR of your here');

  /*
  Graphs to be displayed
    key = name of graph
    value = dotgraph string
    e.g callgraph = callgraphString ....
  */
  const [graphs, setGraphs] = useState({});

  /*
    Messages in codeGPT
  */
  const [savedMessages, setSavedMessages] = useState<{ role: string, content: string }[]>([]);

  /*
    Used to pass prompt from AskCodeGPT to codeGPT
  */
  const [passedPrompt, setPassedPrompt] = useState('');

  const [tabPositions, setTabPositions] = useState<Record<OutputType, string>>({
    Graph: 'main',
    'Terminal Output': 'main',
    CodeGPT: 'main',
    LLVMIR: 'main',
  });

  /*
    Used for when user clicks on a tab.
    When user clicks on a tab, the tab they clicked on is passed onto the function
    render Component then renders the tab
  */
  const renderComponent = (tab: OutputType) => {
    switch (currentOutput) {
      case 'Graph':
        return (
          <DotGraphViewer
            lineNumToHighlight={lineNumToHighlight}
            setlineNumToHighlight={setlineNumToHighlight}
            graphObj={graphs}
            setLineNumDetails={setLineNumDetails}
            lineNumDetails={lineNumDetails}
            currCodeLineNum={currCodeLineNum}
            code={code}
          />
        );
      case 'Terminal Output':
        return <TerminalOutput terminalOutputString={terminalOutputString} />;
      case 'CodeGPT':
        return (
          <CodeGPT
            code={code}
            graphs={graphs}
            terminalOutput={terminalOutputString}
            llvmIR={llvmIRString}
            savedMessages={savedMessages}
            onSaveMessages={setSavedMessages}
            passedPrompt={passedPrompt}
          />
        );
      case 'LLVMIR':
        return <LLVMIR LLVMIRString={llvmIRString} code={code} lineNumDetails={lineNumDetails} setLineNumDetails={setLineNumDetails}/>;
      default:
        return null;
    }
  };

  /*
    Switches to codeGPT tab when user uses AskCodeGPT
  */
  useEffect(() => {
    if (passedPrompt !== '') {
      setCurrentOutput('CodeGPT');
      renderComponent('CodeGPT');
    }
  }, [passedPrompt])


  /*
    Makes API call to backend to run clang and executables using C code given
  */
  const submitCode = async () => {
    const selectedCompileOptionString = selectedCompileOptions.map(option => option.value).join(' ');
    const selectedExecutableOptionsList = selectedExecutableOptions.map(option => option.value);

    const response = await submitCodeFetch(code, selectedCompileOptionString, selectedExecutableOptionsList);
    if ('name' in response) {
      // Successful API call
      if (response.name == 'Resultant Graphs') {
        const respGraphs = response.graphs;
        const graphObj = {};
        respGraphs.forEach(graph => {
          graphObj[graph.name] = graph.graph;
        });
        setGraphs(graphObj);
        setllvmIRString(response.llvm);
        setTerminalOutputString(response.output);
        console.log(response.error);
        setCodeError(formatErrorLogs(response.error));
      // Not successful API call: Clang failed to compile code
      } else if (response.name == 'Clang Error') {
        setTerminalOutputString(response.error);
        setCodeError(formatClangErrors(response.error));
      }
    }
  };

  // It formats the error messages it receives from clang
  // Function is used if it did not pass clang
  const formatClangErrors = (stdErr: string) => {
    const errorList = stdErr.split('\n');
    console.log('formatClangErrors',errorList);
    let errorMsg = '';
    const regex = /example.c:(\d+):(\d+)/;
    let formattedErrors = [];
    // The last element of the array is sentence on how many errors and warnings were generated
    for (let i = 0; i < errorList.length - 1; i++) {
      let match = errorList[i].match(regex);
      if (match) {
        console.log('match', errorList[i]);
        if (errorMsg !== '') {
          formattedErrors.push(errorMsg);
        }
        errorMsg = 'CLANG:\n' + errorList[i];
      } else {
        errorMsg = errorMsg + '\n' +errorList[i];
      }
    }
    if (errorMsg !== '') {
      formattedErrors.push(errorMsg);
    }
    console.log('formattedErrors', formattedErrors);

    return formattedErrors;

  }

  // It formats the Error messages it receives from the SVF tools
  // This is used when the code is compiled by clang
  const formatErrorLogs = (stdErr: string) => {
    console.log('std err is ', stdErr);
    const errorList = stdErr.split('\n');
    console.log('errorList is ', errorList)
    let formattedErrors = [];
    let i = 0;
    let numOverflow = 0;
    while (i < errorList.length) {
      if (errorList[i].includes('NeverFree')) {
        formattedErrors.push('MEMORY LEAK: ' + errorList[i]);
      } else if (errorList[i].includes('######################Buffer Overflow')) {
        numOverflow = parseInt(errorList[i].match(/\d+/)[0], 10);
      } else if (errorList[i].includes("---------------------------------------------") && numOverflow > 0) {
        formattedErrors.push("BUFFER OVERFLOW: " + errorList[i+1] + errorList[i+2]);
        i = i + 2;
        numOverflow--;
      }

      i++;
    }
    return formattedErrors;

  }

  const resetDefault = () => {
    setSelectedCompileOptions([compileOptions[0], compileOptions[1], compileOptions[2], compileOptions[3], compileOptions[4]]);
    setSelectedExecutableOptions([]);
  };

  /*
    Creates a URL based on current C code, selected compile options and executables
    returns a link with compressed settings
  */
  const createLZStringUrl = () => {
    const url = window.location.href;
    const currRoute = url.split('?')[0];
    const savedSettings = {
      code: code,
      selectedCompileOptions: selectedCompileOptions,
      selectedExecutableOptions: selectedExecutableOptions,
    };
    const compressed = compressToEncodedURIComponent(JSON.stringify(savedSettings));
    return currRoute + '?data=' + compressed;
  };

  /*
    Runs when website first loads up
    Checks if there is a LZ string compressed in the URL
    If there is, decompress it and set the code, compile options and executables based
    on the decompressed settings
  */
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    let compressedFromURL = urlParams.get('data');
    if (compressedFromURL) {
      let decompressedSettings: DecompressedSettings = {};
      if (compressedFromURL.startsWith('${')) {
        compressedFromURL = compressedFromURL.replace('${', '');
        const decompressedSettingsString = decompressFromEncodedURIComponent(compressedFromURL);
        decompressedSettings = JSON.parse(decompressedSettingsString);
      } else {
        const decompressedSettingsString = decompressFromEncodedURIComponent(compressedFromURL);
        decompressedSettings = JSON.parse(decompressedSettingsString);
      }
      if (decompressedSettings.hasOwnProperty('code')) {
        setCode(decompressedSettings.code);
      } 
      if (decompressedSettings.hasOwnProperty('selectedCompileOptions')) {
        setSelectedCompileOptions(decompressedSettings.selectedCompileOptions);
      }
      if (decompressedSettings.hasOwnProperty('selectedExecutableOptions')) {
        setSelectedExecutableOptions(decompressedSettings.selectedExecutableOptions);
      }
    }
  }, []);


  /* 
    State if user click on the share 
    True = showing share modal
    False = not showing share modal
  */
  const [openShareModal, setOpenShareModal] = React.useState(false);
  const handleOpenShareModal = () => setOpenShareModal(true);
  const handleCloseShareModal = () => setOpenShareModal(false);
  
  /*
    Link that user can copy to share or save their session 
  */
  const [shareLink, setShareLink] = useState('');

  /*
    When user clicks on the share link icon, 
    it sets it to true,
    we run the createLZstringURL and set the share link for user to copy
   */
  useEffect(() => {
    if (openShareModal === true) {
      setShareLink(createLZStringUrl());
    }
  }, [openShareModal]);


  // Used to allow users to switch the code section and the output section
  const [isCodeLeft, setIsCodeLeft] = useState(true);
  const [draggedElement, setDraggedElement] = useState<string | null>(null);
  const [draggedTab, setDraggedTab] = useState<OutputType | null>(null);

  const handleDragStart = (e: React.DragEvent<HTMLDivElement>, element: string | OutputType) => {
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("draggedItem", String(element));
    
    if (typeof element === "string") {
        setDraggedElement(element);
    } else {
        setDraggedTab(element);
    }
};


  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.currentTarget.classList.add("drag-over");
  };

  const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => {
    e.currentTarget.classList.remove("drag-over");
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.currentTarget.classList.remove("drag-over");

    const target = e.currentTarget.id;
    const draggedItem = e.dataTransfer.getData("draggedItem");

    if (draggedElement && draggedElement !== target) {
        if ((draggedElement === "code" && target === "graph-page-output-container") || 
            (draggedElement === "output" && target === "graph-page-code-container")) {
            setIsCodeLeft(!isCodeLeft);
        }
        setDraggedElement(null);
    } else if (draggedTab) {
        setTabPositions((prev) => ({
            ...prev,
            [draggedTab]: target === 'third-dropzone' ? 'third' : 'main',
        }));
        setDraggedTab(null);
    }
  };


  return (
    <>
      <ShareLZSettingsModal open={openShareModal}
        handleClose={handleCloseShareModal}
        shareLink={shareLink}
        />
      <NavBar 
        openShare={handleOpenShareModal}
      />
      <div id='graph-page-container' style={inlineStyles.container}>
      <div
          id="graph-page-code-container"
          draggable
          onDragStart={(e) => handleDragStart(e, "code")}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          className={isCodeLeft ? 'left' : 'right'}
          style={{ width: '50%' }}
      >
          <SubmitCodeBar
            submitEvent={submitCode}
            resetCompileOptions={resetDefault}
            compileOptions={compileOptions}
            selectedCompileOptions={selectedCompileOptions}
            setSelectedCompileOptions={setSelectedCompileOptions}
            executableOptions={executableOptions}
            selectedExecutableOptions={selectedExecutableOptions}
            setSelectedExecutableOptions={setSelectedExecutableOptions}
          />
          <CodeEditor
            code={code}
            setCode={setCode}
            lineNumToHighlight={lineNumToHighlight}
            lineNumDetails={lineNumDetails}
            setCurrCodeLineNum={setCurrCodeLineNum}
            codeError={codeError}
            setPassedPrompt={setPassedPrompt}
          />
        </div>
        <div
          id="graph-page-output-container"
          draggable
          onDragStart={(e) => handleDragStart(e, "output")}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          className={isCodeLeft ? 'right' : 'left'}
          style={{ width: '50%', display: 'flex', flexDirection: 'column' }}
        >
          <OutputMenuBar
              currentOutput={currentOutput}
              setCurrentOutput={setCurrentOutput}
              onDragStartTab={(tab) => (e: React.DragEvent<HTMLDivElement>) => handleDragStart(e, tab)}
          />
          <div
            style={{ flexGrow: 1 }}
            onDrop={(e) => handleDrop(e)}
            onDragOver={(e) => e.preventDefault()}
          >
            {renderComponent(currentOutput)}
          </div>

          {/* Third Window (will appear when a tab is dragged into it) */}
          {Object.values(tabPositions).includes('third') && (
            <div
              id="graph-page-output-container"
              draggable
              onDragStart={(e) => handleDragStart(e, "output")}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
              onDrop={handleDrop}
              className={isCodeLeft ? 'right' : 'left'}
              style={{ width: '50%', display: 'flex', flexDirection: 'column' }}
            >
              {Object.entries(tabPositions).map(([tab, position]) =>
                position === 'third' ? (
                  <div key={tab} draggable>
                    {renderComponent(tab as OutputType)}
                  </div>
                ) : null
              )}
            </div>
          )}
        </div>
      </div>
    </>
  );
}

export default GraphsPage;
